// Chart updater for AI Village Contribution Dashboard
// Loads real data and updates Chart.js visualizations

class ChartUpdater {
    constructor() {
        this.loader = new DataLoader();
        this.charts = {};
        this.data = {};
    }

    async initialize() {
        console.log('ChartUpdater initializing...');
        
        // Load all data
        await this.loadAllData();
        
        // Update summary metrics
        this.updateSummaryMetrics();
        
        // Update charts with real data
        this.updateCharts();
        
        console.log('ChartUpdater initialized successfully');
    }

    async loadAllData() {
        try {
            this.data.dailyContributions = await this.loader.loadDailyContributions();
            this.data.agentActivity = await this.loader.loadAgentActivity();
            this.data.collaborationNetwork = await this.loader.loadCollaborationNetwork();
            this.data.topicEvolution = await this.loader.loadTopicEvolution();
            this.data.historicalTrends = await this.loader.loadHistoricalTrends();
            
            console.log('Data loaded:', {
                dailyContributions: this.data.dailyContributions?.length || 0,
                agentActivity: this.data.agentActivity?.length || 0,
                collaborationNetwork: this.data.collaborationNetwork?.nodes?.length || 0,
                topicEvolution: this.data.topicEvolution?.currentWeek?.length || 0,
                historicalTrends: this.data.historicalTrends?.length || 0
            });
        } catch (error) {
            console.error('Failed to load data:', error);
        }
    }

    updateSummaryMetrics() {
        if (!this.data.dailyContributions || !this.data.agentActivity) return;
        
        // Calculate total contributions
        const totalContributions = this.data.dailyContributions.reduce((sum, day) => sum + day.total, 0);
        
        // Count active agents
        const activeAgents = this.data.agentActivity.length;
        
        // Calculate collaboration density (simplified)
        const collaborationDensity = this.data.collaborationNetwork?.density || 0.72;
        
        // Determine trending topic (simplified - find max in current week)
        let trendingTopic = "Park Cleanup";
        if (this.data.topicEvolution?.currentWeek) {
            const topics = this.data.topicEvolution.topics || ["Autonomous Ops", "Safety", "Alignment", "Data Quality", "Tooling", "UX Research"];
            const values = this.data.topicEvolution.currentWeek;
            const maxIndex = values.indexOf(Math.max(...values));
            trendingTopic = topics[maxIndex] || "Park Cleanup";
        }
        
        // Update DOM elements
        this.updateMetric('.summary-grid .metric:nth-child(1) strong', totalContributions.toLocaleString());
        this.updateMetric('.summary-grid .metric:nth-child(2) strong', activeAgents.toString());
        this.updateMetric('.summary-grid .metric:nth-child(3) strong', collaborationDensity.toFixed(2));
        this.updateMetric('.summary-grid .metric:nth-child(4) strong', trendingTopic);
        
        // Update trend indicators (simplified)
        const trendTag = document.querySelector('.summary-grid .metric:nth-child(1) .tag');
        if (trendTag) {
            const avgLastWeek = this.calculateWeeklyAverage(this.data.dailyContributions.slice(-14, -7));
            const avgThisWeek = this.calculateWeeklyAverage(this.data.dailyContributions.slice(-7));
            const change = avgLastWeek > 0 ? ((avgThisWeek - avgLastWeek) / avgLastWeek * 100).toFixed(0) : 0;
            trendTag.textContent = `${change >= 0 ? '+' : ''}${change}% vs last week`;
        }
    }

    updateMetric(selector, value) {
        const element = document.querySelector(selector);
        if (element) {
            element.textContent = value;
        }
    }

    calculateWeeklyAverage(days) {
        if (!days || days.length === 0) return 0;
        const total = days.reduce((sum, day) => sum + day.total, 0);
        return total / days.length;
    }

    updateCharts() {
        // Update overview chart (daily contributions)
        this.updateOverviewChart();
        
        // Update agent activity chart
        this.updateAgentChart();
        
        // Update collaboration network chart
        this.updateNetworkChart();
        
        // Update topic evolution chart
        this.updateTopicChart();
        
        // Update historical trends chart
        this.updateTrendChart();
    }

    updateOverviewChart() {
        if (!this.data.dailyContributions) return;
        
        const chart = Chart.getChart('overviewChart');
        if (!chart) return;
        
        // Get last 7 days
        const last7Days = this.data.dailyContributions.slice(-7);
        chart.data.labels = last7Days.map(day => {
            const date = new Date(day.date);
            return date.toLocaleDateString('en-US', { weekday: 'short' });
        });
        chart.data.datasets[0].data = last7Days.map(day => day.total);
        
        chart.update();
    }

    updateAgentChart() {
        if (!this.data.agentActivity) return;
        
        const chart = Chart.getChart('agentChart');
        if (!chart) return;
        
        // Sort agents by total contributions and take top 5
        const sortedAgents = [...this.data.agentActivity]
            .sort((a, b) => b.total - a.total)
            .slice(0, 5);
        
        chart.data.labels = sortedAgents.map(agent => agent.agent);
        chart.data.datasets[0].data = sortedAgents.map(agent => agent.total);
        
        chart.update();
    }

    updateNetworkChart() {
        if (!this.data.collaborationNetwork?.nodes) return;
        
        const chart = Chart.getChart('networkChart');
        if (!chart) return;
        
        // Convert network nodes to bubble chart data
        const nodes = this.data.collaborationNetwork.nodes;
        chart.data.datasets[0].data = nodes.map(node => ({
            x: node.x || Math.random() * 10,
            y: node.y || Math.random() * 10,
            r: node.size || 15
        }));
        
        chart.update();
    }

    updateTopicChart() {
        if (!this.data.topicEvolution) return;
        
        const chart = Chart.getChart('topicChart');
        if (!chart) return;
        
        chart.data.labels = this.data.topicEvolution.topics || 
            ['Autonomous Ops', 'Safety', 'Alignment', 'Data Quality', 'Tooling', 'UX Research'];
        
        if (this.data.topicEvolution.currentWeek) {
            chart.data.datasets[0].data = this.data.topicEvolution.currentWeek;
        }
        
        if (this.data.topicEvolution.lastWeek) {
            chart.data.datasets[1].data = this.data.topicEvolution.lastWeek;
        }
        
        chart.update();
    }

    updateTrendChart() {
        if (!this.data.historicalTrends) return;
        
        const chart = Chart.getChart('trendChart');
        if (!chart) return;
        
        // Assuming historicalTrends is array of monthly data
        const months = this.data.historicalTrends.map(month => month.month);
        const contributions = this.data.historicalTrends.map(month => month.contributions);
        const collaborationScores = this.data.historicalTrends.map(month => month.collaborationScore);
        
        chart.data.labels = months;
        chart.data.datasets[0].data = contributions;
        chart.data.datasets[1].data = collaborationScores;
        
        chart.update();
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
    console.log('AI Village Dashboard - Initializing ChartUpdater');
    
    const updater = new ChartUpdater();
    await updater.initialize();
});
